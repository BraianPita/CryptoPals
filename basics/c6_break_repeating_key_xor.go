package basics

import (
	"fmt"
	"sort"
)

// ---------------------------------- START HAMMING DISTANCE -----------------------------------

var count8bits = [256]uint8{
	0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
}

func HammingDistance(m1 string, m2 string) int {

	// make sure m1 is always the smallest string
	if len(m1) > len(m2) {
		temp := m2
		m2 = m1
		m1 = temp
	}

	m1bytes := []byte(m1)
	m2bytes := []byte(m2)

	dist := 0

	for idx := 0; idx < len(m1); idx++ {
		byteDist := m1bytes[idx] ^ m2bytes[idx]
		// use a lookup table to find the number of
		// 1s in the current xor'd byte
		dist += int(count8bits[byteDist])
	}

	// add up the remaining bits from the string len difference
	dist += (len(m2bytes) - len(m1bytes)) * 8

	return dist
}

// --------------------- END HAMMING DISTANCE - START Base64 Decoder -----------------------

func DecodeBase64(base string) []byte {
	data := make([]byte, 0)

	// TODO: Base64 decoder code

	return data
}

// ---------------------------------- START FIND KEYSIZE -----------------------------------

const MAX_KEY_SIZE = 50

type KeysizeWeight struct {
	Key   int
	Value float32
}

type KeysizeWeightList []KeysizeWeight

func (p KeysizeWeightList) Len() int           { return len(p) }
func (p KeysizeWeightList) Less(i, j int) bool { return p[i].Value < p[j].Value }
func (p KeysizeWeightList) More(i, j int) bool { return p[i].Value > p[j].Value }
func (p KeysizeWeightList) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

func calculateKeySizeWeights(data []byte) KeysizeWeightList {
	keySizeArray := make(KeysizeWeightList, MAX_KEY_SIZE-2)

	for i := 0; i < MAX_KEY_SIZE-2; i++ {
		// +2 to start at keysize 2 (1 and 0 are not options)
		keySizeArray[i] = KeysizeWeight{i + 2, normalizedKeySizeCalculation(i+2, data)}
	}

	sort.Sort(keySizeArray)

	return keySizeArray

}

func normalizedKeySizeCalculation(keysize int, data []byte) float32 {
	// invalid inputs
	if len(data) < keysize*2 {
		return 999.9
	}

	// take the first KEYSIZE worth of bytes, and the second KEYSIZE worth of bytes,
	// and find the edit distance between them. Normalize this result by dividing by KEYSIZE.
	slice1 := data[0:keysize]
	slice2 := data[keysize : keysize*2]

	dist := HammingDistance(string(slice1), string(slice2))

	return float32(dist) / float32(keysize)
}

func chunkSlice(slice []byte, chunkSize int) [][]byte {
	var chunks [][]byte
	for {
		if len(slice) == 0 {
			break
		}

		// necessary check to avoid slicing beyond
		// slice capacity
		if len(slice) < chunkSize {
			chunkSize = len(slice)
		}

		chunks = append(chunks, slice[0:chunkSize])
		slice = slice[chunkSize:]
	}

	return chunks
}

func BreakRepeatingKeyXor(data []byte) {

	weights := calculateKeySizeWeights(data)

	for _, keysize := range weights {
		fmt.Printf("Trying keysize %v - %v\n", keysize.Key, keysize.Value)

	}
	// TODO: Write code to break repeating key xor

}
